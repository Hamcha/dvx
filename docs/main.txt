-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

@package main


module Dvx.Utils

-- | Trim whitespace from a string
trim :: String -> String

-- | Split a list of lists based on a single item separator
splitOn :: Eq a => a -> [a] -> [[a]]

-- | Split a string based on multiple separators while keeping them as
--   items
splitAndKeep :: String -> String -> [String]

-- | Check if a string is an integer
isNumeric :: String -> Bool

-- | Take out the first and last character of a string
middle :: String -> String

-- | Merge a list of lists into a single list
joinsub :: [[a]] -> [a]

-- | Create string tokens from a list of strings This is a workaround to a
--   design fault in our tokenizer
joinstr :: [String] -> Int -> [String] -> [String]

-- | 1 if given True, 0 if given False
boolToInt :: Bool -> Int


module Dvx.Romans

-- | All roman numerals tokens
romanLetters :: String

-- | Converts an integer to its roman numeral representation
dtor :: Int -> String

-- | Converts a roman numeral to its integer value |Throws an error if the
--   given numeral is not valid
rtod :: String -> Int


module Dvx.Tokens

-- | DVX Tokens (derived from code, used in AST building)
data DvxToken
TBool :: Bool -> DvxToken
TColon :: DvxToken
TComma :: DvxToken
TDefn :: DvxToken
TDefnArgs :: DvxToken
TDefVar :: DvxToken
TNullCall :: DvxToken
TPeriod :: DvxToken
TName :: String -> DvxToken
TNil :: DvxToken
TNumber :: Int -> DvxToken
TPrelude :: DvxToken
TSemicolon :: DvxToken
TSpace :: DvxToken
TString :: String -> DvxToken
TVarValue :: DvxToken

-- | Keywords definition
token :: String -> DvxToken
instance Eq DvxToken
instance Show DvxToken


module Dvx.Parser
type Context = [(String, DvxValue)]
type Function = [Context] -> [DvxValue] -> IO DvxValue
data DvxValue
TypeNil :: DvxValue
TypeBool :: Bool -> DvxValue
TypeInt :: Int -> DvxValue
TypeStr :: String -> DvxValue
TypeFun :: Function -> DvxValue
TypeLst :: [DvxValue] -> DvxValue
data DvxExpr
DvxTok :: DvxToken -> DvxExpr
DvxStart :: DvxExpr
DvxConst :: DvxValue -> DvxExpr
DvxVar :: String -> DvxExpr
DvxCall :: String -> [DvxExpr] -> DvxExpr
DvxFunc :: String -> [String] -> DvxExpr -> DvxExpr
DvxDecl :: String -> DvxExpr -> DvxExpr
DvxList :: [DvxExpr] -> DvxExpr
separators :: String
parse :: [DvxToken] -> [DvxExpr]

-- | Makes a fully parsed AST off a raw tree
makeast :: [DvxExpr] -> [DvxExpr]

-- | Parses plain tokens (DvxTok) into something meaningful
discover :: DvxToken -> DvxExpr

-- | Gets a list of strings from a function declaration argument DvxList
getArgs :: [DvxExpr] -> [String]

-- | Parses a list plain tokens (DvxTok) into a tree
parseTokens :: DvxToken -> [DvxExpr] -> [DvxExpr]

-- | Adds token to the beginning of a list, if both arguments are token,
--   create a list of both
prependList :: DvxExpr -> DvxToken -> DvxExpr

-- | Given a String, returns the corresponding token with its semantic
--   value, if any.
parseValue :: String -> DvxToken

-- | Creates a list of tokens off lines of code
tokenize :: [String] -> [DvxToken]
instance Show DvxExpr
instance Show DvxValue


module Dvx.Interpreter

-- | Executes a list of expressions
execute :: [Context] -> [DvxExpr] -> IO ()

-- | Executes a single expression, returning a value and updated context
--   |Throws an error if the expression can't be evaluated
executeExpr :: [Context] -> DvxExpr -> IO (DvxValue, [Context])

-- | Adds a value (variable, function def) to the head of a context chain
appendContext :: [Context] -> String -> DvxValue -> [Context]

-- | Gets a variable from the context chain |Throws an error if it can't
--   find the variable
getVar :: [Context] -> String -> DvxValue

-- | Sets a variable in the context chain
setVar :: [Context] -> String -> DvxExpr -> IO (DvxValue, [Context])

-- | Creates a function from a list of arguments and a return expression
makeFunction :: [String] -> DvxExpr -> Function

-- | Creates a function context based from a list of arguments and their
--   values
bindArgs :: [String] -> [DvxValue] -> Context

-- | Executes an expression where possible, otherwise returns nil
apply :: [Context] -> DvxValue -> [DvxValue] -> IO DvxValue

-- | Retrieves a list of values from a list of expressions |This is just a
--   wrapper over resolveValue
resolve :: [Context] -> [DvxExpr] -> IO [DvxValue]

-- | Retrieves a value from an expression |Works by executing the
--   expression where possible or just looking around in |the context
--   chain.
resolveValue :: [Context] -> DvxExpr -> IO DvxValue


-- | Dvx Standard Context
module Std
data DvxComparable a
CompNil :: DvxComparable a
CompBool :: Bool -> DvxComparable a
CompInt :: Int -> DvxComparable a
CompStr :: String -> DvxComparable a
toComparable :: DvxValue -> DvxComparable a
stdContext :: Context
stdPrint :: Function
stdArith :: (Int -> Int -> Int) -> Int -> Function
stdCmpEq :: (DvxComparable a -> DvxComparable b -> Bool) -> Function
stdCmpOrd :: (DvxComparable a -> DvxComparable b -> Bool) -> Function
stdLogic :: (Bool -> Bool -> Bool) -> Bool -> Function
instance Eq (DvxComparable a)
instance Ord (DvxComparable a)


module Main

-- | Command line flags
data Flag
F_None :: Flag
F_PrintAST :: Flag

-- | Processes the given list of lines depending on what flag is given
--   |"-A" will print the AST instead of executing
process :: Flag -> [String] -> IO ()

-- | Entry point
main :: IO ()

-- | Parses command line flags
parseFlags :: Flag -> [String] -> IO ()

-- | Reads lines of code from stdin
parseStdin :: Flag -> [String] -> Bool -> IO ()
